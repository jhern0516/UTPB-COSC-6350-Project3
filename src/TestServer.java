import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.lang.reflect.Type;
import java.net.*;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.*;

public class TestServer {

    static ArrayList<String> binarySplit = new ArrayList<>();
    public static ArrayList<SecretKey> byteKeyList = new ArrayList<>();
    public static ArrayList<byte[]> encryptedPackets = new ArrayList<>();

    public static void main(String[] args) {
        try {
            //Generates Keys in aes_keys.json file
            KeyGeneration.main(new String[0]);
            //opens sever on port 9999
            ServerSocket serverSocket = new ServerSocket(9999);
            System.out.println("Server listening on port " + 9999);
            //accepts and notifies when client is connected
            Socket clientSocket = serverSocket.accept();
            System.out.println("Client connected.");

            //allows sever to send data out
            DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream());
            //allows sever to receive data
            DataInputStream in = new DataInputStream(clientSocket.getInputStream());

            //reads text file
            BufferedReader reader = new BufferedReader(new FileReader("input.txt"));
            String line;

            // iterates through "line" and sends value to be changed to binary
            while ((line = reader.readLine()) != null) {
                stringToBinary(line);
            }
            reader.close();



            keyGetter();//Receives keys from JSON file

            // encrypts packets and stores them into encrypted packets array list
            for(String bitPair : binarySplit) {
               encryptedPackets.add(encryption(bitPair));
            }

            //sends size of encryptedPackets array to client
          out.writeInt(encryptedPackets.size());
            //iterates through array and sends each index to client for decryption process
          for (byte[] encryptedPacket : encryptedPackets) {
              out.write(encryptedPacket);
              System.out.println("Message decryption is " + checkForPercentage(in) + "% complete.");
            }



        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    //This method will convert string taken from the text file and convert it to its binary representation
    private static void stringToBinary(String text) {
        StringBuilder binary = new StringBuilder();
        for (char c : text.toCharArray()) {
            binary.append(String.format("%8s", Integer.toBinaryString(c)).replace(' ', '0'));
        }
        //This will call and send the string of binary to a method to be converted and stored as crumbs
        binarySplitter(String.valueOf(binary));
    }
    /*
    This method parses string of binary into crumbs and stores those substrings into
    an array list called "binarySplit"
    Note: I probably over complicated this however it's the only that came to mind.
     */
    private static void binarySplitter(String binary) {
        char[] biArr = new char[binary.length()];
        //Stores initial binary string into the array biArr
        for (int i = 0; i < binary.length(); i++) {
            biArr[i] = binary.charAt(i);
        }
        //Parses the string every two bits and adds those values to the Array list binarySplit
        for (int i = 0; i < binary.length(); i += 2) {
            if (i + 1 < binary.length()) {
                String bitPair = "" + biArr[i] + biArr[i + 1];
                binarySplit.add(bitPair);
            }
        }
    }
    /*
    This method used is used within both classes and will retrieve the keys, generated by the KeyGeneration.java class,
    from aes_keys.json
     */
    private static SecretKey keyGetter() throws IOException {
        // NOTE: Gson packages needed to be downloaded into the project.
        Gson gson = new Gson();
        Type type = new TypeToken<HashMap<String, String>>() {
        }.getType();

        try (FileReader reader = new FileReader("aes_keys.json")) {
            // Deserialize the JSON into a HashMap
            HashMap<String, String> keysMap = gson.fromJson(reader, type);

            System.out.println(keysMap);
            // Decode hexadecimal strings back to AES SecretKey objects
            byte[] key1 = decodeKey(keysMap.get("00"));
            byte[] key2 = decodeKey(keysMap.get("01"));
            byte[] key3 = decodeKey(keysMap.get("10"));
            byte[] key4 = decodeKey(keysMap.get("11"));

            //Creates SecretKeys for all keys in byte value
            SecretKey secretKey1 = new SecretKeySpec(key1, "AES");
            SecretKey secretKey2 = new SecretKeySpec(key2, "AES");
            SecretKey secretKey3 = new SecretKeySpec(key3, "AES");
            SecretKey secretKey4 = new SecretKeySpec(key4, "AES");

            byteKeyList.add(secretKey1);
            byteKeyList.add(secretKey2);
            byteKeyList.add(secretKey3);
            byteKeyList.add(secretKey4);

            System.out.println("Keys successfully loaded from aes_keys.json");
        }
        return null;
    }

    /*
    This method will decode the keys generated from hex code back into its byte array form which now viewing I realize that this
    is really redundant and I could've probably left the generated keys as their non-viewable string form then pulled
    that from directly from the JSON file. However, it does work, therefore, I won't fix what isn't broken.
     */
    private static byte[] decodeKey(String hex) {
        int length = hex.length();
        byte[] bytes = new byte[length / 2];

        for (int i = 0; i < length; i += 2) {
            bytes[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)
                    + Character.digit(hex.charAt(i + 1), 16));
        }
        return bytes;
    }
    /*
    This method will pull one crumb at a time from the arrayList and encrypt them based off the crumb orientation.
    I was able to do this by using the bitIndex method.
     */
    private static byte[] encryption(String bitPair) {
        try {
            int keyIndex = bitIndex(bitPair);
            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
           cipher.init(Cipher.ENCRYPT_MODE, byteKeyList.get(keyIndex));
            return cipher.doFinal(bitPair.getBytes());

        } catch (NoSuchPaddingException | NoSuchAlgorithmException |
                 InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
            throw new RuntimeException("Encryption failed", e);
        }
    }
    /*
    This method will help decide which key to use for encryption
     */
    private static int bitIndex(String bitPair) {
            switch (bitPair) {
                case "00" -> {
                    return 0;
                }
                case "01" -> {
                    return 1;
                }
                case "10" -> {
                    return 2;
                }
                case "11" -> {
                    return 3;
                }
                default-> throw new IllegalStateException("Unexpected value: " + bitPair);
            }
    }
    /*
    This method will check with the client on the progress of the decryption
     */
    private static double checkForPercentage(DataInputStream in) throws IOException {
        double completionDecimal = in.readDouble();
        double completionPercentage = completionDecimal * 100.0;
        return completionPercentage;
    }
}

